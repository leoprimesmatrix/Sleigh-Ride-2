
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sleigh Ride 2: Brave New World</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');
    
    body {
      font-family: 'Share Tech Mono', monospace;
      background-color: #000;
      color: #e2e8f0;
      overflow: hidden;
    }

    /* Glitch Effect */
    .glitch-wrapper {
      position: relative;
    }
    
    .glitch {
      position: relative;
      color: white;
      font-family: 'Orbitron', sans-serif;
      letter-spacing: 0.1em;
    }

    .glitch::before,
    .glitch::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }

    .glitch::before {
      left: 2px;
      text-shadow: -1px 0 #ff00c1;
      /* Increased clip width from 450px to 9999px to prevent title cutoff */
      clip: rect(44px, 9999px, 56px, 0);
      animation: glitch-anim 5s infinite linear alternate-reverse;
    }

    .glitch::after {
      left: -2px;
      text-shadow: -1px 0 #00fff9;
      clip: rect(44px, 9999px, 56px, 0);
      animation: glitch-anim2 5s infinite linear alternate-reverse;
    }

    @keyframes glitch-anim {
      0% { clip: rect(38px, 9999px, 84px, 0); transform: skew(0.55deg); }
      5% { clip: rect(66px, 9999px, 5px, 0); transform: skew(0.1deg); }
      10% { clip: rect(25px, 9999px, 96px, 0); transform: skew(0.06deg); }
      15% { clip: rect(6px, 9999px, 5px, 0); transform: skew(0.53deg); }
      20% { clip: rect(69px, 9999px, 57px, 0); transform: skew(0.72deg); }
      25% { clip: rect(58px, 9999px, 90px, 0); transform: skew(0.79deg); }
      30% { clip: rect(32px, 9999px, 1px, 0); transform: skew(0.12deg); }
      35% { clip: rect(10px, 9999px, 83px, 0); transform: skew(0.78deg); }
      40% { clip: rect(40px, 9999px, 5px, 0); transform: skew(0.25deg); }
      45% { clip: rect(33px, 9999px, 60px, 0); transform: skew(0.22deg); }
      50% { clip: rect(21px, 9999px, 18px, 0); transform: skew(0.97deg); }
      55% { clip: rect(78px, 9999px, 31px, 0); transform: skew(0.48deg); }
      60% { clip: rect(43px, 9999px, 35px, 0); transform: skew(0.24deg); }
      65% { clip: rect(38px, 9999px, 16px, 0); transform: skew(0.79deg); }
      70% { clip: rect(59px, 9999px, 20px, 0); transform: skew(0.79deg); }
      75% { clip: rect(6px, 9999px, 30px, 0); transform: skew(0.44deg); }
      80% { clip: rect(59px, 9999px, 7px, 0); transform: skew(0.74deg); }
      85% { clip: rect(98px, 9999px, 96px, 0); transform: skew(0.35deg); }
      90% { clip: rect(12px, 9999px, 4px, 0); transform: skew(0.67deg); }
      95% { clip: rect(65px, 9999px, 2px, 0); transform: skew(0.66deg); }
      100% { clip: rect(47px, 9999px, 75px, 0); transform: skew(0.72deg); }
    }

    @keyframes glitch-anim2 {
      0% { clip: rect(65px, 9999px, 100px, 0); transform: skew(0.78deg); }
      5% { clip: rect(52px, 9999px, 74px, 0); transform: skew(0.21deg); }
      10% { clip: rect(79px, 9999px, 85px, 0); transform: skew(0.11deg); }
      15% { clip: rect(75px, 9999px, 5px, 0); transform: skew(0.05deg); }
      20% { clip: rect(67px, 9999px, 61px, 0); transform: skew(0.81deg); }
      25% { clip: rect(14px, 9999px, 79px, 0); transform: skew(0.71deg); }
      30% { clip: rect(1px, 9999px, 66px, 0); transform: skew(0.85deg); }
      35% { clip: rect(86px, 9999px, 30px, 0); transform: skew(0.92deg); }
      40% { clip: rect(23px, 9999px, 98px, 0); transform: skew(0.72deg); }
      45% { clip: rect(85px, 9999px, 72px, 0); transform: skew(0.93deg); }
      50% { clip: rect(71px, 9999px, 97px, 0); transform: skew(0.14deg); }
      55% { clip: rect(2px, 9999px, 48px, 0); transform: skew(0.97deg); }
      60% { clip: rect(30px, 9999px, 5px, 0); transform: skew(0.04deg); }
      65% { clip: rect(59px, 9999px, 32px, 0); transform: skew(0.05deg); }
      70% { clip: rect(5px, 9999px, 20px, 0); transform: skew(0.03deg); }
      75% { clip: rect(74px, 9999px, 69px, 0); transform: skew(0.72deg); }
      80% { clip: rect(77px, 9999px, 14px, 0); transform: skew(0.76deg); }
      85% { clip: rect(52px, 9999px, 4px, 0); transform: skew(0.64deg); }
      90% { clip: rect(30px, 9999px, 23px, 0); transform: skew(0.43deg); }
      95% { clip: rect(39px, 9999px, 89px, 0); transform: skew(0.76deg); }
      100% { clip: rect(57px, 9999px, 9px, 0); transform: skew(0.8deg); }
    }

    /* CRT Scanline */
    .scanlines {
      background: linear-gradient(
        to bottom,
        rgba(255,255,255,0),
        rgba(255,255,255,0) 50%,
        rgba(0,0,0,0.2) 50%,
        rgba(0,0,0,0.2)
      );
      background-size: 100% 4px;
      animation: scroll 10s linear infinite;
      pointer-events: none;
      z-index: 50;
    }
    
    @keyframes scroll {
      0% { background-position: 0 0; }
      100% { background-position: 0 100%; }
    }

    /* Hologram Grid */
    .holo-grid {
      background-image: 
        linear-gradient(rgba(14, 165, 233, 0.2) 1px, transparent 1px),
        linear-gradient(90deg, rgba(14, 165, 233, 0.2) 1px, transparent 1px);
      background-size: 40px 40px;
      perspective: 500px;
      transform-style: preserve-3d;
      animation: grid-move 20s linear infinite;
    }

    @keyframes grid-move {
      0% { background-position: 0 0; }
      100% { background-position: 40px 40px; }
    }
    
    /* Loading Bar Striped */
    .progress-striped {
      background-image: linear-gradient(
        45deg,
        rgba(0, 0, 0, 0.2) 25%,
        transparent 25%,
        transparent 50%,
        rgba(0, 0, 0, 0.2) 50%,
        rgba(0, 0, 0, 0.2) 75%,
        transparent 75%,
        transparent
      );
      background-size: 20px 20px;
    }

    /* Loader Styles */
    #loader {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background-color: #000;
      z-index: 9999;
      transition: opacity 0.5s;
    }
    .loader-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid #1e293b;
      border-top: 3px solid #0ea5e9;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
      box-shadow: 0 0 15px #0ea5e9;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
    "lucide-react": "https://esm.sh/lucide-react@0.263.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
<body>
  <div id="root"></div>
  
  <div id="loader">
    <div class="loader-spinner"></div>
    <h2 class="font-mono text-xl text-cyan-500 tracking-widest">INITIALIZING_SYSTEM</h2>
    <p id="loader-status" class="text-slate-500 text-xs mt-2 font-mono">LOADING ASSETS...</p>
    <div id="error-container" class="hidden mt-4 p-4 bg-red-900/50 border border-red-500 rounded text-red-200 text-xs text-left max-w-md overflow-auto max-h-60 whitespace-pre-wrap font-mono"></div>
  </div>

  <script>
    async function loadGame() {
      const status = document.getElementById('loader-status');
      const errorContainer = document.getElementById('error-container');
      
      const path = window.location.pathname;
      if (!path.endsWith('/') && !path.endsWith('.html')) {
        const newUrl = window.location.href.replace(path, path + '/');
        window.location.replace(newUrl);
        return; 
      }

      function showError(msg, details = "") {
        status.innerText = "SYSTEM FAILURE";
        status.style.color = "#ef4444";
        errorContainer.classList.remove('hidden');
        errorContainer.innerHTML = `<strong>${msg}</strong><br/><br/>${details}`;
        document.querySelector('.loader-spinner').style.borderColor = '#ef4444';
        document.querySelector('.loader-spinner').style.borderTopColor = '#ef4444';
        document.querySelector('.loader-spinner').style.animation = 'none';
      }

      const fileMap = {
        'types.ts': './types.ts',
        'constants.ts': './constants.ts',
        'audio.ts': './audio.ts',
        'VictorySequence.tsx': './components/VictorySequence.tsx',
        'UIOverlay.tsx': './components/UIOverlay.tsx',
        'GameCanvas.tsx': './components/GameCanvas.tsx',
        'App.tsx': './App.tsx',
        'index.tsx': './index.tsx'
      };

      const blobUrls = {};

      async function fetchWithFallback(url) {
        try {
          const res = await fetch(url);
          if (res.ok) return await res.text();
          throw new Error(`HTTP ${res.status}`);
        } catch (err) {
          const parts = url.split('/');
          const filename = parts.pop();
          const capitalized = filename.charAt(0).toUpperCase() + filename.slice(1);
          const newUrl = [...parts, capitalized].join('/');
          
          if (newUrl !== url) {
             const retryRes = await fetch(newUrl);
             if (retryRes.ok) return await retryRes.text();
          }
          throw err;
        }
      }

      try {
        if (window.location.protocol === 'file:') throw new Error("CORS_ERROR");

        for (const [moduleName, serverPath] of Object.entries(fileMap)) {
          status.innerText = `DECRYPTING ${moduleName}...`;
          
          try {
            let code = await fetchWithFallback(serverPath);
            code = code.replace(/(from\s+['"])(?:.*\/)?([a-zA-Z0-9_-]+\.[a-zA-Z]+)(['"])/g, '$1$2$3');

            const result = Babel.transform(code, {
              presets: [['react', { runtime: 'automatic' }], 'typescript'],
              filename: moduleName,
            });

            const blob = new Blob([result.code], { type: 'text/javascript' });
            blobUrls[moduleName] = URL.createObjectURL(blob);

          } catch (fetchErr) {
            console.error(fetchErr);
            if (fetchErr.message === 'CORS_ERROR') throw new Error("CORS RESTRICTION DETECTED");
            throw new Error(`LOAD ERROR ${moduleName}: ${fetchErr.message}`);
          }
        }

        const existingMapEl = document.querySelector('script[type="importmap"]');
        const imports = existingMapEl ? JSON.parse(existingMapEl.textContent).imports : {};

        for (const [moduleName, blobUrl] of Object.entries(blobUrls)) {
          imports[moduleName] = blobUrl;
        }

        const mapEl = document.createElement('script');
        mapEl.type = 'importmap';
        mapEl.textContent = JSON.stringify({ imports });
        document.head.appendChild(mapEl);

        status.innerText = "EXECUTING...";
        await import(blobUrls['index.tsx']);
        
        const loader = document.getElementById('loader');
        loader.style.opacity = '0';
        setTimeout(() => loader.remove(), 500);

      } catch (error) {
        showError("CRITICAL ERROR", error.message);
      }
    }

    if (typeof Babel !== 'undefined') {
      loadGame();
    } else {
      document.querySelector('script[src*="babel"]').onload = loadGame;
    }
  </script>
</body>
</html>
